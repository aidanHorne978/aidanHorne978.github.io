<!doctype html>
            <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>Snake Game</title>
                <meta name="generator" content="GrapesJS Studio">
                <meta name="viewport" content="width=device-width,initial-scale=1">
                <meta property="og:type" content="website">
                <meta name="robots" content="index,follow">
                <link rel="stylesheet" href="./css/style.css">
              </head>
              <body id="i3va2k"><div id="isx921" class="gjs-grid-row"><div id="iez1qp" class="gjs-grid-column"><div id="i2e667" class="gjs-grid-row"><div id="ioef7l" class="gjs-grid-column"><div id="iaxljg" class="gjs-grid-row"><div id="ipgk3c" class="gjs-grid-column"><a href="./index.html" title="Homepage" id="ibex4l" class="gjs-link">Homepage</a><a href="./projects.html" title="Projects" id="ixj8m7" class="gjs-link">Portfolio</a><a href="./socials.html" id="ihp6n1" class="gjs-link">Contact Me</a></div></div></div></div></div></div><div id="is7qoz" class="gjs-grid-row"><div id="itduxj" class="gjs-grid-column"><img id="ivaysx" src="assets/text_1701468640297.png"/></div></div><div id="iyfq72" class="gjs-grid-row"><div id="i2s24u" class="gjs-grid-column"><div id="i5srbw" class="gjs-grid-row"><div id="iyz7zk" class="gjs-grid-column"><div id="i2xbxj" class="text-main-content">While settling into my new home in Wellington, I decided to do a coding project since it’s been about a year since I did my last one for university. I found a video of someone creating an AI to learn and play snake and thought it’d be a great project to help relearn good coding practices and on a topic I’m partial towards. For the project, I set out with the goal of making it easy for any user to run and play. <br/>This meant I needed to ensure that once the code is ran, the user can:<br/><br/>- bounce between menus<br/>- training the agent<br/>- playing the game (solo or with agent)<br/>- retraining the agent if needed<br/>- viewing the agent.<br/><br/>In the end, I covered all the parts I wanted in it for the user and I’m very happy with the result. Python is a great tool but I definitely found it’s drawbacks with performance to be frustrating.<br/></div></div><div id="inr5j1" class="gjs-grid-column"><video allowfullscreen="allowfullscreen" id="izqy97" src="img/video2.webm" controls></video></div></div></div></div><div id="i06bhe" class="gjs-grid-row"><div id="ityjui" class="gjs-grid-column"><span id="ijg2w3">Genetic Algorithm.</span><div id="i8ct4a" class="gjs-grid-row"><div id="ikdfof" class="gjs-grid-column"><img id="iwwx8f" src="assets/turt.jpg"/><div id="i1wvz4" class="text-main-content"><br/><b>Definition of a genetic algorithm.<br/></b>A genetic algorithm is a problem-solving method inspired by the process of natural selection in evolution. It is used to find the best solution among a set of possible solutions to a given problem. In a genetic algorithm, a population of potential solutions is generated and evolved over generations. Through a process of selection, crossover, and mutation, the algorithm explores and improves the solutions over time, aiming to find the optimal or near-optimal solution.<br/><br/><b>Sigmoid activation function.<br/></b>A sigmoid activation function is a mathematical function commonly used in artificial neural networks. It maps the input values to a range between 0 and 1. The function has an S-shaped curve, resembling the letter "S." The sigmoid function is often used to introduce non-linearity in the output of a neuron, allowing neural networks to model more complex relationships between input and output data. It is particularly useful in tasks like binary classification, where the output needs to be a probability between 0 and 1.<br/><br/><b>Matrix multiplication.<br/></b>Matrix multiplication is widely employed in AI applications, particularly in areas like deep learning and neural networks. In these fields, data is often represented as matrices, where rows indicate input samples and columns represent features or attributes. Matrix multiplication enables the calculation of weighted sums and activation functions across layers of neurons, facilitating the processing and transformation of input data. By performing matrix multiplications between input data and learnable parameters (weights and biases), neural networks can model intricate relationships and make predictions in tasks such as image recognition, speech processing, and recommendation systems. Matrix multiplication serves as a fundamental operation in AI, enabling crucial computations during training and inference processes.<br/><br/><b>Layers of a neural network.<br/></b>My neural network consists of three layers. The first layer serves as the input layer, composed of a 12 by 120 matrix. In this matrix, each column contains information about the current game state, with the first value representing a specific aspect of the state, while the remaining values act as weights that establish connections and relationships within the data. The second layer is a hidden layer, with dimensions of 120 by 120. This layer plays a crucial role in enabling the neural network to learn intricate patterns and establish meaningful connections between the input information. By leveraging the hidden layer, the network becomes capable of capturing complex relationships and extracting valuable insights from the input data. Finally, the last layer is a 120 by 4 matrix. It serves as the output layer, responsible for translating all the processed information into four variables, each representing a possible direction in which the snake can move. Through this translation, the neural network effectively generates predictions or decisions regarding the snake's movement based on the given game state. Overall, this three-layer neural network architecture allows for the transformation and interpretation of the input data, enabling the neural network to learn patterns, extract meaningful relationships, and make<br/></div></div></div></div></div><div id="icn912" class="gjs-grid-row"><div id="idc5ee" class="gjs-grid-column"><div id="i40yxw" class="gjs-grid-row"><div id="iziikh" class="gjs-grid-column"><span id="i8cqdf">Multiprocessing.<br/></span><div id="i2f7ex"><b>Using threading.</b><br/>Threading in Python allows for concurrent execution of different parts of the code. However, in CPython, the Global Interpreter Lock (GIL) limits the execution of Python bytecode to one thread at a time. This can hinder performance for CPU-bound tasks that require parallel execution on multiple cores. Nevertheless, the GIL has less impact on I/O-bound tasks. To overcome GIL limitations, alternative approaches like multiprocessing or using native code can be employed.<br/><br/><b>Using multiple processes.</b><br/>Multiprocessing in Python enables concurrent execution of multiple processes, leveraging multiple CPU cores for efficient parallelism. It bypasses the Global Interpreter Lock (GIL), allowing true parallel execution of CPU-bound tasks. The multiprocessing module provides tools for process management, communication, and synchronization. However, multiprocessing introduces added complexity, requiring explicit mechanisms for inter-process communication and coordination. In my project, I have used pipes to transfer information about the training process to a visual training screen. This screen displays the training results of the current generations and the maximum result achieved in each generation. Care must be taken to avoid race conditions and ensure data integrity. Overall, multiprocessing is a powerful technique for improving performance in CPU-bound tasks by utilizing available hardware resources.<br/><br/><b>Trying different methods and optimizing.<br/></b>While developing this project, I initially attempted to enhance training time by utilizing multi-threading. However, I encountered issues with the Global Interpreter Lock (GIL) that hindered the parallelization of the training task. Recognizing the limitations, I shifted gears and explored multiprocessing. Unfortunately, my initial implementation was flawed. I divided the generation into smaller groups, limiting the number of available parents for crossover and impeding effective learning. However, I didn't give up on the idea of multiprocessing. After careful consideration, I devised a new approach. I successfully parallelized the training process by splitting the current generation and executing their training simultaneously. By dividing them into smaller groups, I could leverage the benefits of multiprocessing while ensuring a sufficient number of parents for crossover. After completing the training, I combined the groups back into a single generation of 40, promoting better learning through a broader selection of parents. This optimization significantly reduced the training time from 20 minutes to just 3 minutes, as documented in my changelog. When the model is training, the screen displayed to the user remains somewhat sluggish, with updates occurring every 3-4 seconds for a small generation and 5-9 seconds for a large generation. Although this aspect could be further optimized, I have come to accept this slight delay. Considering the extensive calculations required during the training process, I believe the current implementation is already operating at its most efficient point. While a complete overhaul might yield incremental improvements, I have made the conscious decision not to undertake such extensive reworking at this stage.</div></div></div></div></div><div id="iagb1l" class="gjs-grid-row"><div id="iiop3q" class="gjs-grid-column"><span id="iq45cf">Training Process.<br/></span><div id="ip0baq" class="gjs-grid-row"><div id="igve0o" class="gjs-grid-column"><img src="assets/good_gen_large.png" id="imauuo"/><div id="irdowz" class="text-main-content"><b>Number of generations.<br/></b>One part of creating a genetic algorithm and a model to fit the problem, is trial and error. Over lots of experimenting, I’ve found that in the best conditions, the model will train in around 25 - 30 generations. It also has the tendency to either train to its full potential (fitness &gt; steps * 200), or struggle to break even on fitness and stay around the -5,000 to -10,000 mark. For my final model, I’ve kept the generations at 75 with a clause (Best agents fitness &gt;= steps * 200) to stop early because we have reached the optimal solution.<br/><br/><b>Number of steps.<br/></b>The performance of the model is significantly influenced by the number of steps taken. As mentioned earlier, the formula for achieving the optimal solution is expressed as (optimal fitness &gt;= steps * 200). In the case of a small model with 1000 steps per generation, the desired optimal fitness would be 200,000 or higher. However, when these models are executed, they exhibit notable weaknesses and appear to be less efficient, as demonstrated in the first video. On the other hand, the large model with 5000 steps per generation demonstrates enhanced efficiency and exhibits more favorable behavior. It achieves a fitness score of 1,000,000 or higher, which signifies a significant improvement compared to the small model. The video evidence showcases the superior performance and behavior of this large model. In summary, the number of steps per generation plays a critical role in determining the model's performance. The small model with 1000 steps falls short in efficiency and exhibits weaknesses, while the large model with 5000 steps demonstrates notable improvements and displays more desirable behavior with a substantially higher fitness score.<br/><br/><b>Fitness function.<br/></b>The fitness function calculates the fitness scores for each agent in a given population. It considers factors such as the agent's highest score, number of deaths, average steps taken, and penalties incurred. The method assigns a score to each agent based on these factors and appends the scores along with their corresponding agent to a list. The method then returns this list of scores, providing a measure of performance for each agent in the population.<br/><br/><b>Crossover.<br/></b>The crossover method performs crossover between the top-performing agents from the previous generation to create the next generation. It divides the best agents into mother and father lists, and then generates a new set of agents by randomly selecting chromosomes from either the mother or father lists. This process continues until the desired population size is reached. The method returns the new children as the next generation of agents, formed through the crossover process.<br/><br/><b>Mutation.<br/></b>The mutation method introduces random mutations to promote diversity and prevent the population from getting stuck in local minima. It first generates a random probability between 0 and 100. If prob is divisible by 48, indicating a low probability event, the method selects a subset of agents in the population for mutation. For each selected agent, it iterates through each chromosome and adds a random value between -1 and 1 to the existing chromosome value. This introduces slight changes to the chromosome values, promoting exploration and potentially improving the population's overall performance. Finally, the method returns the mutated population.<br/></div></div></div></div></div><div id="is8l71" class="gjs-grid-row"><div id="i3b2ek" class="gjs-grid-column"><div id="igxx08" class="gjs-grid-row"><div id="i2jg7w" class="gjs-grid-column"><span id="iy3is2">Gamemodes.<br/></span><video allowfullscreen="allowfullscreen" id="i4mmpf" src="img/video2.webm" controls></video><div id="ip55aa" class="text-main-content">Classic:<br/>You can load up the original snake game and go for a new highscore with the traditional game mode.<br/><br/>Deathmatch.<br/>In the deathmatch game mode, you control the black snake while the AI agent controls the gray snake. The objective is simple: defeat the AI agent by either cutting off its snake's path with your own snake or avoiding collisions with the walls. To win, you need to be smart and quick on your feet. Find opportunities to block the AI agent's movements and trap it in tight spots. Be careful not to crash into the back of the AI agent's snake, or you'll lose the game. If both snake heads collide, it's a draw.<br/><br/>Score Based.<br/>In the turn-based score-based game mode, you and the AI take turns playing the classic game of Snake. The objective is to score as many points as possible during your turn. This gamemode is displayed in the video below.<br/><br/><br/></div></div></div></div></div></body>
            </html>
          
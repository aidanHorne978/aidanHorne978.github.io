<!doctype html>
            <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>Sorting Methods</title>
                <meta name="generator" content="GrapesJS Studio">
                <meta name="viewport" content="width=device-width,initial-scale=1">
                <meta property="og:type" content="website">
                <meta name="robots" content="index,follow">
                <link rel="stylesheet" href="./css/style.css">
              </head>
              <body id="ipz6nx"><div id="ih2n2z" class="gjs-grid-row"><div id="ievt4b" class="gjs-grid-column"><div id="i6sjeg" class="gjs-grid-row"><div id="if3izl" class="gjs-grid-column"><div id="i2csic" class="gjs-grid-row"><div id="inv9ur" class="gjs-grid-column"><a href="./index.html" title="Homepage" id="i1h3eg" class="gjs-link">Homepage</a><a href="./projects.html" title="Projects" id="ir4dvj" class="gjs-link">Portfolio</a><a href="./socials.html" id="i0c1r5" class="gjs-link">Contact Me</a></div></div></div></div></div></div><div id="iif69q" class="gjs-grid-row"><div id="i3bo3p" class="gjs-grid-column"><span id="i2g3x3">Sorting Methods.</span></div></div><div id="ixw4zy" class="gjs-grid-row"><div id="im24of" class="gjs-grid-column"><span id="ifb40q">Insertion Sort.</span><div id="ibw8g4" class="gjs-grid-row"><div id="i6koxv" class="gjs-grid-column"><div id="idhc91">Insertion Sort in Java<br/><br/>Insertion Sort is a straightforward sorting algorithm that incrementally builds a sorted array by iteratively inserting one element at a time into its proper position. While it may not be the most efficient algorithm for large datasets, its simplicity and efficiency on small datasets make it a valuable choice for certain scenarios.<br/><br/>Algorithm Overview:<br/><br/>Start from the second element: Begin with the second element in the array, assuming the first element is already sorted.<br/><br/>Compare and insert: Compare the current element with the elements to its left in the sorted part of the array. Move the elements greater than the current element to the right to make space for the current element, and insert it into the correct position.<br/><br/>Repeat: Continue this process for each unsorted element in the array until the entire array is sorted.<br/></div></div><div id="i4z14g" class="gjs-grid-column"><iframe allowfullscreen="allowfullscreen" id="i89gvb" src="https://www.youtube-nocookie.com/embed/watch?"></iframe></div></div><div id="i97s8k" class="gjs-grid-row"><div id="i997vm" class="gjs-grid-column"><div id="i9rsj6">Time Complexity (Big O Notation):<br/><br/>The time complexity of Insertion Sort is O(n^2) in the worst case, where 'n' is the number of elements in the array. This is because, for each element in the unsorted part of the array, the algorithm may need to make comparisons and shifts within the sorted part. In the best case (when the array is already sorted), the time complexity is O(n). Despite its quadratic time complexity, Insertion Sort can outperform other algorithms for small datasets due to its simplicity and low constant factors.Insert your text here</div></div></div></div></div><div id="iszswf" class="gjs-grid-row"><div id="isupn4" class="gjs-grid-column"><span id="i47rdc">Selection Sort.</span><div id="i1785y" class="gjs-grid-row"><div id="icghgh" class="gjs-grid-column"><div id="ilmyrn">Selection Sort in Java<br/><br/>Selection Sort is a simple, comparison-based sorting algorithm that divides the input array into a sorted and an unsorted region. The algorithm repeatedly selects the minimum element from the unsorted region and swaps it with the first element of the unsorted region. This process continues until the entire array is sorted.<br/><br/>Algorithm Overview:<br/><br/>Selection: Find the minimum element in the unsorted region of the array.<br/><br/>Swap: Swap the minimum element with the first element of the unsorted region.<br/><br/>Increment: Move the boundary between the sorted and unsorted regions one position to the right.<br/><br/>Repeat: Repeat the above steps until the entire array is sorted.<br/></div></div><div id="i4mvrv" class="gjs-grid-column"><iframe allowfullscreen="allowfullscreen" id="iirxfn" src="https://www.youtube-nocookie.com/embed/watch?"></iframe></div></div><div id="iji8z9" class="gjs-grid-row"><div id="i1tg0c" class="gjs-grid-column"><div id="idq4pa"><span id="iwn8es">Time Complexity (Big O Notation):</span><br id="i5uyjl"/><br id="ikw69h"/><span id="igd1ak">The time complexity of Selection Sort is O(n^2) in all cases, where 'n' is the number of elements in the array. Selection Sort has a quadratic time complexity, making it less efficient than some other sorting algorithms, especially on large datasets. However, its simplicity and the fact that it performs a constant number of swaps per pass can make it useful for small datasets or partially sorted arrays.</span></div></div></div></div></div><div id="i6ndyr" class="gjs-grid-row"><div id="i37a7z" class="gjs-grid-column"><span id="i1a9nr">Merge Sort.</span><div id="ig370k" class="gjs-grid-row"><div id="ivibeg" class="gjs-grid-column"><div id="i86fhj">Merge Sort in Java<br/><br/>Merge Sort is an efficient, comparison-based sorting algorithm that follows the divide-and-conquer paradigm. It divides the unsorted array into 'n' sub-arrays, each containing one element, and then repeatedly merges the sub-arrays to produce new sorted sub-arrays until only one sub-array remains, resulting in a fully sorted array.<br/><br/>Algorithm Overview:<br/><br/>Divide: Divide the unsorted array into 'n' sub-arrays, each containing one element.<br/><br/>Conquer: Recursively merge adjacent pairs of sub-arrays until only one sub-array remains.<br/><br/>Merge: Merge the sorted sub-arrays to produce new sorted sub-arrays until a fully sorted array is achieved.<br/></div></div><div id="ig8z5k" class="gjs-grid-column"><iframe allowfullscreen="allowfullscreen" id="i5k9es" src="https://www.youtube-nocookie.com/embed/watch?"></iframe></div></div><div id="itlsqh" class="gjs-grid-row"><div id="i7qbty" class="gjs-grid-column"><div id="iex1pu"><span id="ijhhzo">Time Complexity (Big O Notation):</span><br id="iph40z"/><br id="ixybrj"/><span id="idvqgh">The time complexity of Merge Sort is O(n log n) in all cases, where 'n' is the number of elements in the array. This makes Merge Sort more efficient than many other sorting algorithms, especially for large datasets. The divide-and-conquer approach ensures a consistent time complexity, making it a reliable choice for various scenarios.</span></div></div></div></div></div><div id="i4ae6a" class="gjs-grid-row"><div id="iwp2pf" class="gjs-grid-column"><span id="i3g1gi">Quick Sort.</span><div id="ihe0h7" class="gjs-grid-row"><div id="ibvaj6" class="gjs-grid-column"><div id="i05nji">Quick Sort in Java<br/><br/>Quick Sort is a highly efficient, comparison-based sorting algorithm known for its fast average-case performance. It follows the divide-and-conquer approach, selecting a 'pivot' element and partitioning the array into two sub-arrays, such that elements less than the pivot are on the left, and elements greater than the pivot are on the right. The sub-arrays are then recursively sorted.<br/><br/>Algorithm Overview:<br/><br/>Select Pivot: Choose a pivot element from the array. The choice of pivot can significantly affect the algorithm's performance.<br/><br/>Partitioning: Rearrange the elements in the array such that elements less than the pivot are on the left, and elements greater than the pivot are on the right.<br/><br/>Recursion: Recursively apply the same process to the sub-arrays created by the partitioning step.<br/></div></div><div id="it91oi" class="gjs-grid-column"><iframe allowfullscreen="allowfullscreen" id="ixtu5h" src="https://www.youtube-nocookie.com/embed/watch?"></iframe></div></div><div id="ivmo4y" class="gjs-grid-row"><div id="i910uw" class="gjs-grid-column"><div id="i1o741"><span id="iyp5nk">Time Complexity (Big O Notation):</span><br id="i4xqdq"/><br id="i1ixb1"/><span id="i3td3f">The average and best-case time complexity of Quick Sort is O(n log n), where 'n' is the number of elements in the array. In the worst case, however, the time complexity is O(n^2), but this is rare and can be mitigated with proper pivot selection strategies. Quick Sort's average-case performance, low constant factors, and in-place nature make it a popular choice for sorting large datasets.</span></div></div></div></div></div></body>
            </html>
          